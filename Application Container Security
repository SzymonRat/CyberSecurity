Operating system (OS) virtualization provides a separate virtualized view of the OS to each
application, thereby keeping each application isolated from all others on the server. Each
application can only see and affect itself. Recently, OS virtualization has become increasingly
popular due to advances in its ease of use and a greater focus on developer agility as a key
benefit. Today’s OS virtualization technologies are primarily focused on providing a portable,
reusable, and automatable way to package and run applications

The following methoda can help increase a security of the application containers:

1. Tailor the organization’s operational culture and technical processes to support the new
way of developing, running, and supporting applications made possible by containers

2. Use container-specific host OSs instead of general-purpose ones to reduce attack surfaces.

      A container-specific host OS is a minimalist OS explicitly designed to only run containers, with
all other services and functionality disabled, and with read-only file systems and other hardening
practices employed. When using a container-specific host OS, attack surfaces are typically much
smaller than they would be with a general-purpose host OS, so there are fewer opportunities to
attack and compromise a container-specific host OS.

3. Only group containers with the same purpose, sensitivity, and threat posture on a single
host OS kernel to allow for additional defense in depth.

      While most container platforms do an effective job of isolating containers from each other and
from the host OS, it may be an unnecessary risk to run apps of different sensitivity levels
together on the same host OS. Segmenting containers by purpose, sensitivity, and threat posture
provides additional defense in depth. By grouping containers in this manner, organizations make
it more difficult for an attacker who compromises one of the groups to expand that compromise
to other groups. This increases the likelihood that compromises will be detected and contained
and also ensures that any residual data, such as caches or local volumes mounted for temp files,
stays within its security zone.
In larger-scale environments with hundreds of hosts and thousands of containers, this grouping
must be automated to be practical to operationalize. Fortunately, container technologies typically
include some notion of being able to group apps together, and container security tools can use
attributes like container names and labels to enforce security policies across them.

4. Adopt container-specific vulnerability management tools and processes for images to
prevent compromises

 Organizations should adopt tools and processes to validate and enforce
compliance with secure configuration best practices for images. This should include having
centralized reporting and monitoring of the compliance state of each image, and preventing noncompliant images from being run.

5. Consider using hardware-based countermeasures to provide a basis for trusted computing

6. Use container-aware runtime defense tool

    Deploy and use a dedicated container security solution capable of preventing, detecting, and
responding to threats aimed at containers during runtime. Traditional security solutions, such as
intrusion prevention systems (IPSs) and web application firewalls (WAFs), often do not provide
suitable protection for containers. They may not be able to operate at the scale of containers,
manage the rate of change in a container environment, and have visibility into container activity.
Utilize a container-native security solution that can monitor the container environment and
provide precise detection of anomalous and malicious activity within it.

======================================================================================

Every host OS used for running containers has binaries that establish and maintain the
environment for each container, also known as the container runtime. The container runtime
coordinates multiple OS components that isolate resources and resource usage so that each
container sees its own dedicated view of the OS and is isolated from other containers running
concurrently. Effectively, the containers and the host OS interact through the container runtime.
The container runtime also provides management tools and application programming interfaces
(APIs) to allow DevOps personnel and others to specify how to run containers on a given host.
The runtime eliminates the need to manually create all the necessary configurations and
simplifies the process of starting, stopping, and operating containers. Examples of runtimes
include Docker , rkt , and the Open Container Initiative Daemon 

Examples of technical capabilities the container runtime ensures the host OS provides include
the following:

 1. Namespace isolation
 
 2. Resource allocation
 
 3. Filesystem virtualization
 
 
================================================================================================

Major risk for core components for container technologies:

1. Image vulnerabilities
  
     Because images are effectively static archive files that include all the components used to run a
given app, components within an image may be missing critical security updates or are otherwise
outdated.

2. Image configuration defects

3. Embedded malware

4. Embedded clear text secrets

5. Use od untrusted images

6. Insecure connections to regsitries

7. Insufficient authentication & authorization restrictions

8. Orchestrator configuration defects

9. Host OS file system tempering

10. Improper user access rights

11. Host OS component vulnerabilities

12. Shared kernel

13. Rogue containers

14. App vulnerabilities

15. Insecure container runtime configuration

16. Unbound network access from containers

17. Orchestrator Node trust

18. Mixing of workload sensitivity

19. Poorly separated inter-container traffic

20. Unauthorized access

21. Unbound administrative access
=============================================================
























